---
title: "Drawing Figure for manuscript"
author: "incheol, hyunsu"
date: "July 27, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data load
```{r, message=FALSE, warning=FALSE}
setwd("../Data_prep/divided_data")

cre_na_omitted <- read.csv("cre_na_omitted.csv", row.names = "X")

Btrain		<- read.csv("Btrain.csv", row.names = "X")
Btrain.l	<- read.csv("Btrain_long.csv", header = T, row.names = "X")
Btrain.s	<- read.csv("Btrain_short.csv", header = T, row.names = "X")
Btrain.r	<- read.csv("Btrain_ramp.csv", header = T, row.names = "X")

Btest		<- read.csv("Btest.csv", row.names = "X")
Btest.l		<- read.csv("Btest_long.csv", header = T, row.names = "X")
Btest.s		<- read.csv("Btest_short.csv", header = T, row.names = "X")
Btest.r		<- read.csv("Btest_ramp.csv", header = T, row.names = "X")

Etrain		<- read.csv("Etrain.csv", row.names = "X")
Etrain.l	<- read.csv("Etrain_long.csv", header = T, row.names = "X")
Etrain.s	<- read.csv("Etrain_short.csv", header = T, row.names = "X")
Etrain.r	<- read.csv("Etrain_ramp.csv", header = T, row.names = "X")

Etest		<- read.csv("Etest.csv", row.names = "X")
Etest.l		<- read.csv("Etest_long.csv", header = T, row.names = "X")
Etest.s		<- read.csv("Etest_short.csv", header = T, row.names = "X")
Etest.r		<- read.csv("Etest_ramp.csv", header = T, row.names = "X")

Itrain		<- read.csv("Itrain.csv", row.names = "X")
Itrain.l	<- read.csv("Itrain_long.csv", header = T, row.names = "X")
Itrain.s	<- read.csv("Itrain_short.csv", header = T, row.names = "X")
Itrain.r	<- read.csv("Itrain_ramp.csv", header = T, row.names = "X")

Itest		<- read.csv("Itest.csv", row.names = "X")
Itest.l		<- read.csv("Itest_long.csv", header = T, row.names = "X")
Itest.s		<- read.csv("Itest_short.csv", header = T, row.names = "X")
Itest.r		<- read.csv("Itest_ramp.csv", header = T, row.names = "X")
```


# make function for split vion plot
* https://stackoverflow.com/questions/35717353/split-violin-plot-with-ggplot2

```{r, message=FALSE, warning=FALSE}
require(ggplot2)
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin, draw_group = function(self, data, ..., draw_quantiles = NULL){
  data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
  grp <- data[1,'group']
  newdata <- plyr::arrange(transform(data, x = if(grp%%2==1) xminv else xmaxv), if(grp%%2==1) y else -y)
  newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
  newdata[c(1,nrow(newdata)-1,nrow(newdata)), 'x'] <- round(newdata[1, 'x']) 
  if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
    stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 
                                              1))
    quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
    aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
    aesthetics$alpha <- rep(1, nrow(quantiles))
    both <- cbind(quantiles, aesthetics)
    quantile_grob <- GeomPath$draw_panel(both, ...)
    ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
  }
  else {
    ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
  }
})

geom_split_violin <- function (mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ..., draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) {
  layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin, position = position, show.legend = show.legend, inherit.aes = inherit.aes, params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}
```

# Draw figure2 split violin plots

```{r, message=FALSE, warning=FALSE}
require(ggplot2)
require(reshape)
require(latex2exp)
require(gridExtra)


fig2data <- cre_na_omitted[ , !names(cre_na_omitted) %in% c("transgenic_line")]
fig2meltdata <- melt(fig2data, id = c("binary_neuron"))

levels(fig2meltdata$variable) <- c("$\\Alpha_{index}$", "$\\ISI_{avg}$", "$\\FR/I$", "$\\t^{long}_{FT}$", "$\\t^{ramp}_{FT}$", "$\\t^{short}_{FT}$", "$\\V^{long}_{FT}$", "$\\V^{ramp}_{FT}$", "$\\V^{short}_{FT}$", "$\\IR$", "$\\t^{long}_{lat}$", "$\\t^{long}_{P}$", "$\\t^{ramp}_{P}$", "$\\t^{short}_{P}$", "$\\V^{long}_{P}$", "$\\V^{ramp}_{P}$", "$\\V^{short}_{P}$", "$\\R_{m}$", "$\\Sag$", "$\\t^{short}_{ST}$", "$\\V^{short}_{ST}$", "$\\I^{long}_{\\Theta}$", "$\\I^{ramp}_{\\Theta}$", "$\\I^{short}_{\\Theta}$", "$\\t^{long}_{\\Theta}$", "$\\t^{ramp}_{\\Theta}$", "$\\t^{short}_{\\Theta}$", "$\\V^{long}_{\\Theta}$", "$\\V^{ramp}_{\\Theta}$", "$\\V^{short}_{\\Theta}$", "$\\t^{long}_{T}$", "$\\t^{ramp}_{T}$", "$\\t^{short}_{T}$", "$\\V^{long}_{T}$", "$\\V^{ramp}_{T}$", "$\\V^{short}_{T}$",  "$\\rho^{long}$", "$\\rho^{ramp}$", "$\\rho^{short}$", "$\\V_{Sag}$", "$\\V_{rest}$", "$\\H$", "$\\FR")

# 1st row of figure2(mV)
v_filter <-fig2meltdata[grep("V", fig2meltdata$variable), ]
v_filter_wo_p <- v_filter[grep("[^P]\\}\\$$", v_filter$variable), ]

fig2_1 <- ggplot(data = v_filter_wo_p, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "right") + labs(x = "", y = "mV") +
   scale_x_discrete(labels = parse(text = TeX(unique(v_filter_wo_p$variable)))) + 
  scale_fill_discrete(name = "", labels = c("E", "I")) +theme(axis.title.y = element_text(size = rel(0.7))) + theme(legend.text = element_text(size = rel(0.5)))

# https://chemicalstatistician.wordpress.com/2018/03/10/use-unique-instead-of-levels-to-find-the-possible-values-of-a-character-variable-in-r/


# 2nd row of figure2(mV, ratio, resistance)
over_zero_v_filter <- rbind(v_filter[grep("P", v_filter$variable), ],
                       fig2meltdata[grep("H", fig2meltdata$variable), ])
fig2_21 <- ggplot(data = over_zero_v_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "mV") +
   scale_x_discrete(labels = parse(text = TeX(unique(over_zero_v_filter$variable)))) + theme(axis.title.y = element_text(size = rel(0.7)))

up_d_ratio <- fig2meltdata[grep("rho", fig2meltdata$variable), ]
fig2_22 <- ggplot(data = up_d_ratio, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "") +
  scale_x_discrete(labels = parse(text = TeX(unique(up_d_ratio$variable)))) + theme(axis.title.y = element_text(size = rel(0.7)))

adaptation <- fig2meltdata[grep("inde", fig2meltdata$variable), ]
fig2_23 <- ggplot(data = adaptation, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "") + 
  scale_x_discrete(labels = parse(text =TeX(unique(adaptation$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

sag <- fig2meltdata[grep("Sag\\$", fig2meltdata$variable), ]
fig2_24 <- ggplot(data = sag, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "") +
  scale_x_discrete(labels = parse(text =TeX(unique(sag$variable)))) + theme(axis.title.y = element_text(size = rel(0.7)))

resist <- fig2meltdata[grep("[^F]R", fig2meltdata$variable), ]
fig2_25 <- ggplot(data = resist, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = TeX('$\\m\\Omega$')) +
  scale_x_discrete(labels = parse(text =TeX(unique(resist$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

fig2_2 <- grid.arrange(fig2_21, fig2_22, fig2_23, fig2_24, fig2_25, widths = c(4,3,1.5,1.5,2), nrow = 1)

# 3rd row of figure2(ms, firing)
t_long_filter <- rbind(fig2meltdata[grep("t\\^\\{long\\}_\\{[^l]", fig2meltdata$variable), ],
                  fig2meltdata[grep("t\\^\\{short\\}_\\{T", fig2meltdata$variable), ],
                  fig2meltdata[grep("t\\^\\{short\\}_\\{S", fig2meltdata$variable), ])
fig2_31 <- ggplot(data = t_long_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() +theme(legend.position = "none") + labs(x= "", y = "mS") +
  scale_x_discrete(labels = parse(text =TeX(unique(t_long_filter$variable)))) + theme(axis.title.y = element_text(size = rel(0.7)))

latency <- fig2meltdata[grep("lat", fig2meltdata$variable), ]
fig2_32 <- ggplot(data = latency, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "S") +
  scale_x_discrete(labels = parse(text =TeX(unique(latency$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

avg_isi <- fig2meltdata[grep("avg", fig2meltdata$variable), ]
fig2_33 <- ggplot(data = avg_isi, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "mS") +
  scale_x_discrete(labels = parse(text =TeX(unique(avg_isi$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

firing_rate <- fig2meltdata[grep("FR$", fig2meltdata$variable), ]
fig2_34 <- ggplot(data = firing_rate, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "spikes/s") +
  scale_x_discrete(labels = parse(text =TeX(unique(firing_rate$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

f_i_curve <- fig2meltdata[grep("FR/", fig2meltdata$variable), ]
fig2_35 <- ggplot(data = f_i_curve, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "spikes/s/pA") +
  scale_x_discrete(labels = parse(text =TeX(unique(f_i_curve$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

fig2_3 <- grid.arrange(fig2_31, fig2_32, fig2_33, fig2_34, fig2_35, widths = c(6,1.5, 1.5, 1.5, 1.5), nrow=1)


# 4th row of figure2(ms, pA)
t_filter <- fig2meltdata[grep("t\\^\\{short", fig2meltdata$variable), ]

t_short_filter <- rbind(t_filter[grep("FT\\}\\$$", t_filter$variable), ], 
                        t_filter[grep("[^T]\\}\\$$", t_filter$variable), ])
fig2_41 <- ggplot(data = t_short_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x= "", y = "mS") +
  scale_x_discrete(labels = parse(text =TeX(unique(t_short_filter$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

t_ramp_filter <- fig2meltdata[grep("t\\^\\{ramp", fig2meltdata$variable), ]
fig2_42 <- ggplot(data = t_ramp_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "ms") +
  scale_x_discrete(labels = parse(text =TeX(unique(t_ramp_filter$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

i_filter <- fig2meltdata[grep("I\\^", fig2meltdata$variable), ]
fig2_43 <- ggplot(data = i_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + scale_y_log10() + theme(legend.position = "none") + labs(x = "", y = "pA") +
  scale_x_discrete(labels = parse(text =TeX(unique(i_filter$variable)))) +theme(axis.title.y = element_text(size = rel(0.7))) 

fig2_4 <- grid.arrange(fig2_41, fig2_42, fig2_43, widths = c(3,4,3), nrow = 1)

# arrange violin plots
fig2_l <- grid.arrange(fig2_1, fig2_2, fig2_3, fig2_4, ncol = 1)


# for heatmap, correlation matrix

fig2data_numeric <- cre_na_omitted[ , !names(cre_na_omitted) %in% c("transgenic_line", "binary_neuron")]

colnames(fig2data_numeric) <- c("$\\Alpha_{index}$", "$\\ISI_{avg}$", "$\\FR/I$", "$\\t^{long}_{FT}$", "$\\t^{ramp}_{FT}$", "$\\t^{short}_{FT}$", "$\\V^{long}_{FT}$", "$\\V^{ramp}_{FT}$", "$\\V^{short}_{FT}$", "$\\IR$", "$\\t^{long}_{lat}$", "$\\t^{long}_{P}$", "$\\t^{ramp}_{P}$", "$\\t^{short}_{P}$", "$\\V^{long}_{P}$", "$\\V^{ramp}_{P}$", "$\\V^{short}_{P}$", "$\\R_{m}$", "$\\Sag$", "$\\t^{short}_{ST}$", "$\\V^{short}_{ST}$", "$\\I^{long}_{\\Theta}$", "$\\I^{ramp}_{\\Theta}$", "$\\I^{short}_{\\Theta}$", "$\\t^{long}_{\\Theta}$", "$\\t^{ramp}_{\\Theta}$", "$\\t^{short}_{\\Theta}$", "$\\V^{long}_{\\Theta}$", "$\\V^{ramp}_{\\Theta}$", "$\\V^{short}_{\\Theta}$", "$\\t^{long}_{T}$", "$\\t^{ramp}_{T}$", "$\\t^{short}_{T}$", "$\\V^{long}_{T}$", "$\\V^{ramp}_{T}$", "$\\V^{short}_{T}$",  "$\\rho^{long}$", "$\\rho^{ramp}$", "$\\rho^{short}$", "$\\V_{Sag}$", "$\\V_{rest}$", "$\\H$", "$\\FR")



cormat <- cor(fig2data_numeric)
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
cormat <- reorder_cormat(cormat)
melted_fig2b<-melt(cormat)
melted_fig2b$X1 <- factor(melted_fig2b$X1, levels=unique(as.character(melted_fig2b$X1)))
melted_fig2b$X2 <- factor(melted_fig2b$X2, levels=unique(as.character(melted_fig2b$X2)))
fig2_r <- ggplot(data=melted_fig2b, aes(X1, X2, fill=value))+geom_tile() + scale_fill_gradient2(low = "darkolivegreen4", high = "firebrick2", mid = "lightgoldenrodyellow", 
   midpoint = 0, limit = c(-1,1), space = "Lab", name="r") +labs(x = "", y = "")+theme(legend.position = "none") + scale_y_discrete(position = "right", labels = parse(text =TeX(unique(melted_fig2b$X1)))) + theme(axis.ticks.x = element_blank(), axis.text.x = element_blank(), axis.ticks.y = element_blank()) +theme(axis.title.y = element_text(size = rel(0.7)))
# TODO figure grid arrange. 
fig2<- grid.arrange(fig2_l, fig2_r, widths = c(1.6,1), nrow = 1)

ggsave("fig2.tiff",fig2, width=11, height=7, units ="in", dpi = 300)
```

# Binary classification

## Conventional decision according to firing rate
```{r, message=FALSE, warning=FALSE}
require(ROCR)
x.conven <- cre_na_omitted$firing_rate
preds = (x.conven-min(x.conven))/(max(x.conven)-min(x.conven)) # probability로 conversion
# con.preds = (x.conven-min(x.conven))/(max(x.conven)-min(x.conven)) # probability로 conversion

conventional.pred = prediction(preds,cre_na_omitted$binary_neuron)
conventional.perf = performance(conventional.pred,"tpr","fpr")
conventional.auc  =performance(conventional.pred,'auc')
```

## Load ANN results
```{r}
setwd("../ANN/results")
B.ANN.full <-read.csv("00_4_binary_full_ANNmodel_prob.csv",header=F) 
B.ANN.long <-read.csv("01_4_binary_long_ANNmodel_prob.csv",header=F)
B.ANN.short<-read.csv("02_4_binary_short_ANNmodel_prob.csv",header=F)
B.ANN.ramp <-read.csv("03_4_binary_ramp_ANNmodel_prob.csv",header=F)

E.ANN.full <-read.csv("04_4_Eline_full_argmax.csv",header=F) 
E.ANN.long <-read.csv("05_4_Eline_long_argmax.csv",header=F)
E.ANN.short<-read.csv("06_4_Eline_short_argmax.csv",header=F)
E.ANN.ramp <-read.csv("07_4_Eline_ramp_argmax.csv",header=F)

I.ANN.full <-read.csv("08_4_Iline_full_argmax.csv",header=F) 
I.ANN.long <-read.csv("09_4_Iline_long_argmax.csv",header=F)
I.ANN.short<-read.csv("10_4_Iline_short_argmax.csv",header=F)
I.ANN.ramp <-read.csv("11_4_Iline_ramp_argmax.csv",header=F)
```
## Checking the performance of ANN model of binary classification
```{r}
# ROC curve & AUC
library(ROCR)
BrocANN <- function(model) {
pred = prediction(model[,1],Btest$binary_neuron)
au<-performance(pred,"auc")
cat(substitute(model),": ",au@y.values[[1]],"\n")
return(performance(pred,"tpr","fpr"))
}

# Plotting ROC Curves
cat("conventional: ",conventional.auc@y.values[[1]],"\n")
plot(conventional.perf,col=2,lwd=0.5,main="ROC Curves (ANN)")
plot(BrocANN(B.ANN.full),col=3,lwd=0.5,add=T)
plot(BrocANN(B.ANN.long),col=4,lwd=0.5,add=T)
plot(BrocANN(B.ANN.short),col=5,lwd=0.5,add=T)
plot(BrocANN(B.ANN.ramp),col=6,lwd=0.5,add=T)


abline(a=0,b=1,lwd=1,lty=2,col="gray")
legend("bottomright",col=c(2:10),lwd=2,legend=c("firing_rate","ANN_full","ANN_long","ANN_short","ANN_ramp"),bty='n') 
```


# Load LASSO and RF models
```{r, message=FALSE, warning=FALSE}
setwd("../lasso_rf/")

model_files <- list.files("./R_models/")

for (file_name in model_files){
  load(paste0("./R_models/",file_name))
} 
```





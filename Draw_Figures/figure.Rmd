---
title: "Drawing Figure for manuscript"
author: "incheol, hyunsu"
date: "July 27, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data load
```{r, message=FALSE, warning=FALSE}
setwd("../Data_prep/divided_data")

cre_na_omitted <- read.csv("cre_na_omitted.csv", row.names = "X")

Btrain		<- read.csv("Btrain.csv", row.names = "X")
Btrain.l	<- read.csv("Btrain_long.csv", header = T, row.names = "X")
Btrain.s	<- read.csv("Btrain_short.csv", header = T, row.names = "X")
Btrain.r	<- read.csv("Btrain_ramp.csv", header = T, row.names = "X")

Btest		<- read.csv("Btest.csv", row.names = "X")
Btest.l		<- read.csv("Btest_long.csv", header = T, row.names = "X")
Btest.s		<- read.csv("Btest_short.csv", header = T, row.names = "X")
Btest.r		<- read.csv("Btest_ramp.csv", header = T, row.names = "X")

Etrain		<- read.csv("Etrain.csv", row.names = "X")
Etrain.l	<- read.csv("Etrain_long.csv", header = T, row.names = "X")
Etrain.s	<- read.csv("Etrain_short.csv", header = T, row.names = "X")
Etrain.r	<- read.csv("Etrain_ramp.csv", header = T, row.names = "X")

Etest		<- read.csv("Etest.csv", row.names = "X")
Etest.l		<- read.csv("Etest_long.csv", header = T, row.names = "X")
Etest.s		<- read.csv("Etest_short.csv", header = T, row.names = "X")
Etest.r		<- read.csv("Etest_ramp.csv", header = T, row.names = "X")

Itrain		<- read.csv("Itrain.csv", row.names = "X")
Itrain.l	<- read.csv("Itrain_long.csv", header = T, row.names = "X")
Itrain.s	<- read.csv("Itrain_short.csv", header = T, row.names = "X")
Itrain.r	<- read.csv("Itrain_ramp.csv", header = T, row.names = "X")

Itest		<- read.csv("Itest.csv", row.names = "X")
Itest.l		<- read.csv("Itest_long.csv", header = T, row.names = "X")
Itest.s		<- read.csv("Itest_short.csv", header = T, row.names = "X")
Itest.r		<- read.csv("Itest_ramp.csv", header = T, row.names = "X")
```

# TODO Figure 2 drawing in final2_hyunsu.Rmd line 1521. 

```{r, message=FALSE, warning=FALSE}
require(latex2exp)
plot(1, main = TeX('$\\theta$'))
```

```{r, message=FALSE, warning=FALSE}
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin, draw_group = function(self, data, ..., draw_quantiles = NULL){
  data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
  grp <- data[1,'group']
  newdata <- plyr::arrange(transform(data, x = if(grp%%2==1) xminv else xmaxv), if(grp%%2==1) y else -y)
  newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
  newdata[c(1,nrow(newdata)-1,nrow(newdata)), 'x'] <- round(newdata[1, 'x']) 
  if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
    stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 
                                              1))
    quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
    aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
    aesthetics$alpha <- rep(1, nrow(quantiles))
    both <- cbind(quantiles, aesthetics)
    quantile_grob <- GeomPath$draw_panel(both, ...)
    ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
  }
  else {
    ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
  }
})

geom_split_violin <- function (mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ..., draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) {
  layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin, position = position, show.legend = show.legend, inherit.aes = inherit.aes, params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}
```
```{r, message=FALSE, warning=FALSE}
require(ggplot2)
require(reshape)
require(latex2exp)

fig2data <- cre_na_omitted[ , !names(cre_na_omitted) %in% 
                                      c("transgenic_line")]
fig2meltdata <- melt(fig2data, id = c("binary_neuron"))

t_ramp_filter <- fig2meltdata[grep("_t_ramp", fig2meltdata$variable), ]

ggplot(data = t_ramp_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

t_long_filter <- rbind(fig2meltdata[grep("_t_long", fig2meltdata$variable), ],
                       fig2meltdata[grep("^trough_t_short", fig2meltdata$variable), ], 
                       fig2meltdata[grep("^slow_trough_t_short", fig2meltdata$variable), ])

ggplot(data = t_long_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

t_short_filter <- rbind(fig2meltdata[grep("[^h]_t_short", fig2meltdata$variable), ], 
                        fig2meltdata[grep("fast_trough_t_short", fig2meltdata$variable), ])

ggplot(data = t_short_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

avg_isi <- fig2meltdata[grep("avg_isi", fig2meltdata$variable), ]
ggplot(data = avg_isi, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

latency <- fig2meltdata[grep("latency", fig2meltdata$variable), ]
ggplot(data = latency, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

peak_v_filter <- rbind(fig2meltdata[grep("k_v_", fig2meltdata$variable), ],
                       fig2meltdata[grep("hei", fig2meltdata$variable), ])

ggplot(data = peak_v_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

v_filter <-rbind(fig2meltdata[grep("[^k]_v_", fig2meltdata$variable), ],
fig2meltdata[grep("vrest", fig2meltdata$variable), ],
fig2meltdata[grep("r_sag", fig2meltdata$variable), ])

ggplot(data = v_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()


i_filter <- fig2meltdata[grep("d_i_", fig2meltdata$variable), ]

ggplot(data = i_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + scale_y_log10()

resist <- rbind(fig2meltdata[grep("^input", fig2meltdata$variable), ],
                fig2meltdata[grep("^ri", fig2meltdata$variable), ])
ggplot(data = resist, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

adaptation <- fig2meltdata[grep("^ada", fig2meltdata$variable), ]
ggplot(data = adaptation, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

sag <- fig2meltdata[grep("^sag", fig2meltdata$variable), ]
ggplot(data = sag, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

up_d_ratio <- fig2meltdata[grep("^up", fig2meltdata$variable), ]
ggplot(data = up_d_ratio, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

f_i_curve <- fig2meltdata[grep("^f_", fig2meltdata$variable), ]
ggplot(data = f_i_curve, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()

firing_rate <- fig2meltdata[grep("^fir", fig2meltdata$variable), ]
ggplot(data = firing_rate, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal()
# TODO figure grid arrange. 

```

# Binary classification

## Conventional decision according to firing rate
```{r, message=FALSE, warning=FALSE}
require(ROCR)
x.conven <- cre_na_omitted$firing_rate
preds = (x.conven-min(x.conven))/(max(x.conven)-min(x.conven)) # probability로 conversion
# con.preds = (x.conven-min(x.conven))/(max(x.conven)-min(x.conven)) # probability로 conversion

conventional.pred = prediction(preds,cre_na_omitted$binary_neuron)
conventional.perf = performance(conventional.pred,"tpr","fpr")
conventional.auc  =performance(conventional.pred,'auc')
```

## Load ANN results
```{r}
setwd("../ANN/results")
B.ANN.full <-read.csv("00_4_binary_full_ANNmodel_prob.csv",header=F) 
B.ANN.long <-read.csv("01_4_binary_long_ANNmodel_prob.csv",header=F)
B.ANN.short<-read.csv("02_4_binary_short_ANNmodel_prob.csv",header=F)
B.ANN.ramp <-read.csv("03_4_binary_ramp_ANNmodel_prob.csv",header=F)

E.ANN.full <-read.csv("04_4_Eline_full_argmax.csv",header=F) 
E.ANN.long <-read.csv("05_4_Eline_long_argmax.csv",header=F)
E.ANN.short<-read.csv("06_4_Eline_short_argmax.csv",header=F)
E.ANN.ramp <-read.csv("07_4_Eline_ramp_argmax.csv",header=F)

I.ANN.full <-read.csv("08_4_Iline_full_argmax.csv",header=F) 
I.ANN.long <-read.csv("09_4_Iline_long_argmax.csv",header=F)
I.ANN.short<-read.csv("10_4_Iline_short_argmax.csv",header=F)
I.ANN.ramp <-read.csv("11_4_Iline_ramp_argmax.csv",header=F)
```
## Checking the performance of ANN model of binary classification
```{r}
# ROC curve & AUC
library(ROCR)
BrocANN <- function(model) {
pred = prediction(model[,1],Btest$binary_neuron)
au<-performance(pred,"auc")
cat(substitute(model),": ",au@y.values[[1]],"\n")
return(performance(pred,"tpr","fpr"))
}

# Plotting ROC Curves
cat("conventional: ",conventional.auc@y.values[[1]],"\n")
plot(conventional.perf,col=2,lwd=0.5,main="ROC Curves (ANN)")
plot(BrocANN(B.ANN.full),col=3,lwd=0.5,add=T)
plot(BrocANN(B.ANN.long),col=4,lwd=0.5,add=T)
plot(BrocANN(B.ANN.short),col=5,lwd=0.5,add=T)
plot(BrocANN(B.ANN.ramp),col=6,lwd=0.5,add=T)


abline(a=0,b=1,lwd=1,lty=2,col="gray")
legend("bottomright",col=c(2:10),lwd=2,legend=c("firing_rate","ANN_full","ANN_long","ANN_short","ANN_ramp"),bty='n') 
```


# Load LASSO and RF models
```{r, message=FALSE, warning=FALSE}
setwd("../lasso_rf/")

model_files <- list.files("./R_models/")

for (file_name in model_files){
  load(paste0("./R_models/",file_name))
} 
```





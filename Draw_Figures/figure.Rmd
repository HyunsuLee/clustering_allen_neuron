---
title: "Drawing Figure for manuscript"
author: "incheol, hyunsu"
date: "July 27, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data load
```{r, message=FALSE, warning=FALSE}
setwd("../Data_prep/divided_data")

cre_na_omitted <- read.csv("cre_na_omitted.csv", row.names = "X")

Btrain		<- read.csv("Btrain.csv", row.names = "X")
Btrain.l	<- read.csv("Btrain_long.csv", header = T, row.names = "X")
Btrain.s	<- read.csv("Btrain_short.csv", header = T, row.names = "X")
Btrain.r	<- read.csv("Btrain_ramp.csv", header = T, row.names = "X")

Btest		<- read.csv("Btest.csv", row.names = "X")
Btest.l		<- read.csv("Btest_long.csv", header = T, row.names = "X")
Btest.s		<- read.csv("Btest_short.csv", header = T, row.names = "X")
Btest.r		<- read.csv("Btest_ramp.csv", header = T, row.names = "X")

Etrain		<- read.csv("Etrain.csv", row.names = "X")
Etrain.l	<- read.csv("Etrain_long.csv", header = T, row.names = "X")
Etrain.s	<- read.csv("Etrain_short.csv", header = T, row.names = "X")
Etrain.r	<- read.csv("Etrain_ramp.csv", header = T, row.names = "X")

Etest		<- read.csv("Etest.csv", row.names = "X")
Etest.l		<- read.csv("Etest_long.csv", header = T, row.names = "X")
Etest.s		<- read.csv("Etest_short.csv", header = T, row.names = "X")
Etest.r		<- read.csv("Etest_ramp.csv", header = T, row.names = "X")

Itrain		<- read.csv("Itrain.csv", row.names = "X")
Itrain.l	<- read.csv("Itrain_long.csv", header = T, row.names = "X")
Itrain.s	<- read.csv("Itrain_short.csv", header = T, row.names = "X")
Itrain.r	<- read.csv("Itrain_ramp.csv", header = T, row.names = "X")

Itest		<- read.csv("Itest.csv", row.names = "X")
Itest.l		<- read.csv("Itest_long.csv", header = T, row.names = "X")
Itest.s		<- read.csv("Itest_short.csv", header = T, row.names = "X")
Itest.r		<- read.csv("Itest_ramp.csv", header = T, row.names = "X")
```


# make function for split vion plot
* https://stackoverflow.com/questions/35717353/split-violin-plot-with-ggplot2

```{r, message=FALSE, warning=FALSE}
require(ggplot2)
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin, draw_group = function(self, data, ..., draw_quantiles = NULL){
  data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
  grp <- data[1,'group']
  newdata <- plyr::arrange(transform(data, x = if(grp%%2==1) xminv else xmaxv), if(grp%%2==1) y else -y)
  newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
  newdata[c(1,nrow(newdata)-1,nrow(newdata)), 'x'] <- round(newdata[1, 'x']) 
  if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
    stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 
                                              1))
    quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
    aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
    aesthetics$alpha <- rep(1, nrow(quantiles))
    both <- cbind(quantiles, aesthetics)
    quantile_grob <- GeomPath$draw_panel(both, ...)
    ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
  }
  else {
    ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
  }
})

geom_split_violin <- function (mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ..., draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) {
  layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin, position = position, show.legend = show.legend, inherit.aes = inherit.aes, params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}
```

# Draw figure2 split violin plots

```{r, message=FALSE, warning=FALSE}
require(ggplot2)
require(reshape2)
require(latex2exp)
require(gridExtra)


fig2data <- cre_na_omitted[ , !names(cre_na_omitted) %in% c("transgenic_line")]
fig2meltdata <- melt(fig2data, id = c("binary_neuron"))

levels(fig2meltdata$variable) <- c("$\\Alpha_{index}$", "$\\ISI_{avg}$", "$\\FR/I$", "$\\t^{long}_{FT}$", "$\\t^{ramp}_{FT}$", "$\\t^{short}_{FT}$", "$\\V^{long}_{FT}$", "$\\V^{ramp}_{FT}$", "$\\V^{short}_{FT}$", "$\\IR$", "$\\t^{long}_{lat}$", "$\\t^{long}_{P}$", "$\\t^{ramp}_{P}$", "$\\t^{short}_{P}$", "$\\V^{long}_{P}$", "$\\V^{ramp}_{P}$", "$\\V^{short}_{P}$", "$\\R_{m}$", "$\\Sag$", "$\\t^{short}_{ST}$", "$\\V^{short}_{ST}$", "$\\I^{long}_{\\Theta}$", "$\\I^{ramp}_{\\Theta}$", "$\\I^{short}_{\\Theta}$", "$\\t^{long}_{\\Theta}$", "$\\t^{ramp}_{\\Theta}$", "$\\t^{short}_{\\Theta}$", "$\\V^{long}_{\\Theta}$", "$\\V^{ramp}_{\\Theta}$", "$\\V^{short}_{\\Theta}$", "$\\t^{long}_{T}$", "$\\t^{ramp}_{T}$", "$\\t^{short}_{T}$", "$\\V^{long}_{T}$", "$\\V^{ramp}_{T}$", "$\\V^{short}_{T}$",  "$\\rho^{long}$", "$\\rho^{ramp}$", "$\\rho^{short}$", "$\\V_{Sag}$", "$\\V_{rest}$", "$\\H$", "$\\FR")

# 1st row of figure2(mV)
v_filter <-fig2meltdata[grep("V", fig2meltdata$variable), ]
v_filter_wo_p <- v_filter[grep("[^P]\\}\\$$", v_filter$variable), ]

fig2_1 <- ggplot(data = v_filter_wo_p, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "right") + labs(x = "", y = "mV") +
   scale_x_discrete(labels = parse(text = TeX(unique(v_filter_wo_p$variable)))) + 
  scale_fill_discrete(name = "", labels = c("E", "I")) +theme(axis.title.y = element_text(size = rel(0.7))) + theme(legend.text = element_text(size = rel(0.5)))

# https://chemicalstatistician.wordpress.com/2018/03/10/use-unique-instead-of-levels-to-find-the-possible-values-of-a-character-variable-in-r/


# 2nd row of figure2(mV, ratio, resistance)
over_zero_v_filter <- rbind(v_filter[grep("P", v_filter$variable), ],
                       fig2meltdata[grep("H", fig2meltdata$variable), ])
fig2_21 <- ggplot(data = over_zero_v_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "mV") +
   scale_x_discrete(labels = parse(text = TeX(unique(over_zero_v_filter$variable)))) + theme(axis.title.y = element_text(size = rel(0.7)))

up_d_ratio <- fig2meltdata[grep("rho", fig2meltdata$variable), ]
fig2_22 <- ggplot(data = up_d_ratio, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "") +
  scale_x_discrete(labels = parse(text = TeX(unique(up_d_ratio$variable)))) + theme(axis.title.y = element_text(size = rel(0.7)))

adaptation <- fig2meltdata[grep("inde", fig2meltdata$variable), ]
fig2_23 <- ggplot(data = adaptation, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "") + 
  scale_x_discrete(labels = parse(text =TeX(unique(adaptation$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

sag <- fig2meltdata[grep("Sag\\$", fig2meltdata$variable), ]
fig2_24 <- ggplot(data = sag, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "") +
  scale_x_discrete(labels = parse(text =TeX(unique(sag$variable)))) + theme(axis.title.y = element_text(size = rel(0.7)))

resist <- fig2meltdata[grep("[^F]R", fig2meltdata$variable), ]
fig2_25 <- ggplot(data = resist, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = TeX('$\\m\\Omega$')) +
  scale_x_discrete(labels = parse(text =TeX(unique(resist$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

fig2_2 <- grid.arrange(fig2_21, fig2_22, fig2_23, fig2_24, fig2_25, widths = c(4,3,1.5,1.5,2), nrow = 1)

# 3rd row of figure2(ms, firing)
t_long_filter <- rbind(fig2meltdata[grep("t\\^\\{long\\}_\\{[^l]", fig2meltdata$variable), ],
                  fig2meltdata[grep("t\\^\\{short\\}_\\{T", fig2meltdata$variable), ],
                  fig2meltdata[grep("t\\^\\{short\\}_\\{S", fig2meltdata$variable), ])
fig2_31 <- ggplot(data = t_long_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() +theme(legend.position = "none") + labs(x= "", y = "mS") +
  scale_x_discrete(labels = parse(text =TeX(unique(t_long_filter$variable)))) + theme(axis.title.y = element_text(size = rel(0.7)))

latency <- fig2meltdata[grep("lat", fig2meltdata$variable), ]
fig2_32 <- ggplot(data = latency, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "S") +
  scale_x_discrete(labels = parse(text =TeX(unique(latency$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

avg_isi <- fig2meltdata[grep("avg", fig2meltdata$variable), ]
fig2_33 <- ggplot(data = avg_isi, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "mS") +
  scale_x_discrete(labels = parse(text =TeX(unique(avg_isi$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

firing_rate <- fig2meltdata[grep("FR$", fig2meltdata$variable), ]
fig2_34 <- ggplot(data = firing_rate, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "spikes/s") +
  scale_x_discrete(labels = parse(text =TeX(unique(firing_rate$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

f_i_curve <- fig2meltdata[grep("FR/", fig2meltdata$variable), ]
fig2_35 <- ggplot(data = f_i_curve, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "spikes/s/pA") +
  scale_x_discrete(labels = parse(text =TeX(unique(f_i_curve$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

fig2_3 <- grid.arrange(fig2_31, fig2_32, fig2_33, fig2_34, fig2_35, widths = c(6,1.5, 1.5, 1.5, 1.5), nrow=1)


# 4th row of figure2(ms, pA)
t_filter <- fig2meltdata[grep("t\\^\\{short", fig2meltdata$variable), ]

t_short_filter <- rbind(t_filter[grep("FT\\}\\$$", t_filter$variable), ], 
                        t_filter[grep("[^T]\\}\\$$", t_filter$variable), ])
fig2_41 <- ggplot(data = t_short_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x= "", y = "mS") +
  scale_x_discrete(labels = parse(text =TeX(unique(t_short_filter$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

t_ramp_filter <- fig2meltdata[grep("t\\^\\{ramp", fig2meltdata$variable), ]
fig2_42 <- ggplot(data = t_ramp_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + theme(legend.position = "none") + labs(x = "", y = "ms") +
  scale_x_discrete(labels = parse(text =TeX(unique(t_ramp_filter$variable)))) +theme(axis.title.y = element_text(size = rel(0.7)))

i_filter <- fig2meltdata[grep("I\\^", fig2meltdata$variable), ]
fig2_43 <- ggplot(data = i_filter, aes(x = variable, y = value, fill = binary_neuron)) + 
  geom_split_violin() + theme_minimal() + scale_y_log10() + theme(legend.position = "none") + labs(x = "", y = "pA") +
  scale_x_discrete(labels = parse(text =TeX(unique(i_filter$variable)))) +theme(axis.title.y = element_text(size = rel(0.7))) 

fig2_4 <- grid.arrange(fig2_41, fig2_42, fig2_43, widths = c(3,4,3), nrow = 1)

# arrange violin plots
fig2_l <- grid.arrange(fig2_1, fig2_2, fig2_3, fig2_4, ncol = 1)


# for heatmap, correlation matrix

fig2data_numeric <- cre_na_omitted[ , !names(cre_na_omitted) %in% c("transgenic_line", "binary_neuron")]

colnames(fig2data_numeric) <- c("$\\Alpha_{index}$", "$\\ISI_{avg}$", "$\\FR/I$", "$\\t^{long}_{FT}$", "$\\t^{ramp}_{FT}$", "$\\t^{short}_{FT}$", "$\\V^{long}_{FT}$", "$\\V^{ramp}_{FT}$", "$\\V^{short}_{FT}$", "$\\IR$", "$\\t^{long}_{lat}$", "$\\t^{long}_{P}$", "$\\t^{ramp}_{P}$", "$\\t^{short}_{P}$", "$\\V^{long}_{P}$", "$\\V^{ramp}_{P}$", "$\\V^{short}_{P}$", "$\\R_{m}$", "$\\Sag$", "$\\t^{short}_{ST}$", "$\\V^{short}_{ST}$", "$\\I^{long}_{\\Theta}$", "$\\I^{ramp}_{\\Theta}$", "$\\I^{short}_{\\Theta}$", "$\\t^{long}_{\\Theta}$", "$\\t^{ramp}_{\\Theta}$", "$\\t^{short}_{\\Theta}$", "$\\V^{long}_{\\Theta}$", "$\\V^{ramp}_{\\Theta}$", "$\\V^{short}_{\\Theta}$", "$\\t^{long}_{T}$", "$\\t^{ramp}_{T}$", "$\\t^{short}_{T}$", "$\\V^{long}_{T}$", "$\\V^{ramp}_{T}$", "$\\V^{short}_{T}$",  "$\\rho^{long}$", "$\\rho^{ramp}$", "$\\rho^{short}$", "$\\V_{Sag}$", "$\\V_{rest}$", "$\\H$", "$\\FR")



cormat <- cor(fig2data_numeric)
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
cormat <- reorder_cormat(cormat)
melted_fig2b<-melt(cormat)
melted_fig2b$Var1 <- factor(melted_fig2b$Var1, levels=unique(as.character(melted_fig2b$Var1)))
melted_fig2b$Var2 <- factor(melted_fig2b$Var2, levels=unique(as.character(melted_fig2b$Var2)))
fig2_r <- ggplot(data=melted_fig2b, aes(Var1, Var2, fill=value)) + 
      geom_tile() + scale_fill_gradient2(low = "darkolivegreen4", high = "firebrick2", mid = "lightgoldenrodyellow", 
                    midpoint = 0, limit = c(-1,1), space = "Lab", name="r") +
      labs(x = "", y = "")+
      theme(legend.position = "bottom") + 
      scale_y_discrete(position = "right", labels = parse(text =TeX(unique(melted_fig2b$Var1)))) + 
      theme(axis.ticks.x = element_blank(), axis.text.x = element_blank(), axis.ticks.y = element_blank()) +
      theme(axis.title.y = element_text(size = rel(0.7)))

fig2<- grid.arrange(fig2_l, fig2_r, widths = c(1.6,1), nrow = 1)

ggsave("fig2.tiff",fig2, width=11, height=7, units ="in", dpi = 300)
ggsave("fig2_violin.tiff", fig2_l, width = 11, height = 7, units = "in", dpi = 300)
ggsave("fig2_heatmap.tiff", fig2_r, width = 7, height = 7, units = "in", dpi = 300)
```


# redraw pie chart(figure3) to cumulative bar chart.
```{r, message=FALSE, warning=FALSE}
require(ggplot2)
require(gridExtra)

Btrain_freq <- as.data.frame(prop.table(table(Btrain$binary)))
Btest_freq <- as.data.frame(prop.table(table(Btest$binary)))
Btrain_freq <- cbind(Btrain_freq, 'train')
Btest_freq <- cbind(Btest_freq, 'test')
colnames(Btrain_freq) <- c("neuron", "probability", "set")
colnames(Btest_freq) <- c("neuron", "probability", "set")
Bpro <- rbind(Btrain_freq, Btest_freq)

fig3_1 <- ggplot(Bpro, aes(x = set, y = probability, fill = neuron)) + 
  geom_bar(stat="identity") + # for cumulative bar graph
  theme_minimal() + scale_fill_brewer(type = "seq", palette = "Paired") +
  labs(x = "", y = "", fill = "") + 
  coord_flip() + scale_x_discrete(limits = rev(levels(Bpro$set))) + # xy axis swap and reverse order of set
  theme(legend.position = "top", axis.text.x = element_blank())


Etrain_freq <- as.data.frame(prop.table(table(Etrain$transgenic_line)))
Etest_freq <- as.data.frame(prop.table(table(Etest$transgenic_line)))
Etrain_freq <- cbind(Etrain_freq, 'train')
Etest_freq <- cbind(Etest_freq, 'test')
colnames(Etrain_freq) <- c("neuron", "probability", "set")
colnames(Etest_freq) <- c("neuron", "probability", "set")
Epro <- rbind(Etrain_freq, Etest_freq)

fig3_2 <- ggplot(Epro, aes(x = set, y = probability, fill = neuron)) + 
  geom_bar(stat="identity") + 
  theme_minimal() + scale_fill_brewer(type = "seq", palette = "Spectral") +
  labs(x = "", y = "", fill  = "excitatory line") + 
  coord_flip() + scale_x_discrete(limits = rev(levels(Epro$set))) + 
  theme(legend.position = "top", axis.text.x = element_blank(), axis.ticks.y = element_blank())

Itrain_freq <- as.data.frame(prop.table(table(Itrain$transgenic_line)))
Itest_freq <- as.data.frame(prop.table(table(Itest$transgenic_line)))
Itrain_freq <- cbind(Itrain_freq, 'train')
Itest_freq <- cbind(Itest_freq, 'test')
colnames(Itrain_freq) <- c("neuron", "probability", "set")
colnames(Itest_freq) <- c("neuron", "probability", "set")
Ipro <- rbind(Itrain_freq, Itest_freq)

fig3_3 <- ggplot(Ipro, aes(x = set, y = probability, fill = neuron)) + 
  geom_bar(stat="identity") + 
  theme_minimal() + scale_fill_brewer(type = "seq", palette = "Spectral") +
  labs(x = "", fill = "inhibitory line") + 
  coord_flip() + scale_x_discrete(limits = rev(levels(Ipro$set))) + 
  theme(legend.position = "top", axis.ticks.y = element_blank())

fig3 <- grid.arrange(fig3_1, fig3_2, fig3_3, ncol = 1)

ggsave("fig3.tiff", fig3, width = 10, height = 5, units = "in", dpi = 300)
```

# Binary classification

## Conventional decision according to firing rate
```{r, message=FALSE, warning=FALSE}
require(ROCR)
x.conven <- cre_na_omitted$firing_rate
preds = (x.conven-min(x.conven))/(max(x.conven)-min(x.conven)) # probability conversion
# con.preds = (x.conven-min(x.conven))/(max(x.conven)-min(x.conven)) # probability conversion

x.updownratio <- cre_na_omitted$upstroke_downstroke_ratio_short_square
preds_ud = (x.updownratio-min(x.updownratio))/(max(x.updownratio)-min(x.updownratio))


conventional.pred = prediction(preds, cre_na_omitted$binary_neuron, label.ordering = c("Excitatory", "Inhibitory"))
conventional.perf = performance(conventional.pred,"tpr","fpr")
conventional.auc  =performance(conventional.pred,"auc")

udratio_pred = prediction(preds_ud, cre_na_omitted$binary_neuron, label.ordering = c("Inhibitory", "Excitatory"))
udratio_perf = performance(udratio_pred, "tpr", "fpr")
udratio_auc = performance(udratio_pred, "auc")
```

## Load ANN results
```{r, message=FALSE, warning=FALSE}
setwd("../ANN/results")
B.ANN.full <-read.csv("00_4_binary_full_ANNmodel_prob.csv",header=F) 
B.ANN.long <-read.csv("01_4_binary_long_ANNmodel_prob.csv",header=F)
B.ANN.short<-read.csv("02_4_binary_short_ANNmodel_prob.csv",header=F)
B.ANN.ramp <-read.csv("03_4_binary_ramp_ANNmodel_prob.csv",header=F)

E.ANN.full <-read.csv("04_4_Eline_full_argmax.csv",header=F) 
E.ANN.long <-read.csv("05_4_Eline_long_argmax.csv",header=F)
E.ANN.short<-read.csv("06_4_Eline_short_argmax.csv",header=F)
E.ANN.ramp <-read.csv("07_4_Eline_ramp_argmax.csv",header=F)

I.ANN.full <-read.csv("08_4_Iline_full_argmax.csv",header=F) 
I.ANN.long <-read.csv("09_4_Iline_long_argmax.csv",header=F)
I.ANN.short<-read.csv("10_4_Iline_short_argmax.csv",header=F)
I.ANN.ramp <-read.csv("11_4_Iline_ramp_argmax.csv",header=F)
```

## Checking the performance of ANN model of binary classification
```{r, message=FALSE, warning=FALSE}
# ROC curve & AUC
library(ROCR)
BrocANN <- function(model) {
    pred = prediction(model[,1],Btest$binary_neuron)
    au<-performance(pred,"auc")
    cat(substitute(model),": ",au@y.values[[1]],"\n")
    return(performance(pred,"tpr","fpr"))
}

# Plotting ROC Curves
cat("conventional: ",conventional.auc@y.values[[1]],"\n")
cat("up_down_ratio: ",udratio_auc@y.values[[1]],"\n")
plot(conventional.perf,col=2,lwd=0.5,main="ROC Curves (ANN)")
plot(BrocANN(B.ANN.full),col=3,lwd=0.5,add=T)
plot(BrocANN(B.ANN.long),col=4,lwd=0.5,add=T)
plot(BrocANN(B.ANN.short),col=5,lwd=0.5,add=T)
plot(BrocANN(B.ANN.ramp),col=6,lwd=0.5,add=T)
plot(udratio_perf, col=7, lwd=0.5, add=T)


abline(a=0,b=1,lwd=1,lty=2,col="gray")
legend("bottomright",col=c(2:10),lwd=2,legend=c("firing_rate","ANN_full","ANN_long","ANN_short","ANN_ramp","ud_ratio"),bty='n') 
```


# Load LASSO and RF models
```{r, message=FALSE, warning=FALSE}
setwd("../lasso_rf/")

model_files <- list.files("./R_models/")

for (file_name in model_files){
  load(paste0("./R_models/",file_name))
} 


```


# Draw Figure 4 classification E vs I, ROC curves and accuracy bar plot
https://stackoverflow.com/questions/24303203/creating-roc-curve-with-ggplot
```{r, message=FALSE, warning=FALSE}
require(ggplot2)
library(ROCR)
library(magrittr)
library(caret)


# TODO create data.frame for drawing ROC curve for each input feature, models(full, long, short, ramp//LASSO, RF, ANN)

BrocANN <- function(model) {
    pred <- prediction(model[,1],Btest$binary_neuron)
    fpr<- performance(pred,"tpr","fpr")@x.values[[1]]
    tpr<- performance(pred,"tpr","fpr")@y.values[[1]]
    result <- cbind(fpr, tpr)
    results <- cbind.data.frame(result, paste(substitute(model)))
    colnames(results) <- c("fpr", "tpr", "model")
    return(results)
}

prediction(B.ANN.full[,1], Btest$binary_neuron)

ANN_full_ROC <- BrocANN(B.ANN.full)

Broc <- function(model, dataset) {
     pred_ <- predict(model, type="prob", newdata=dataset)[,2]
     pred <- prediction(pred_, Btest$binary_neuron)
     fpr<- performance(pred,"tpr","fpr")@x.values[[1]]
     tpr<- performance(pred,"tpr","fpr")@y.values[[1]]
     result <- cbind(fpr, tpr)
     result <- cbind.data.frame(result, paste(substitute(model)))
     colnames(result) <- c("fpr", "tpr", "model")
     return(result)
}

reg_full_ROC <- Broc(B.reg.full.nocv, Btest)
rf_full_ROC <- Broc(B.rf.full.nocv, Btest)


full_ROC <- rbind(ANN_full_ROC, reg_full_ROC, rf_full_ROC)

ggplot(data=full_ROC, aes(fpr, tpr, color = model)) + geom_line()

ANN_long_ROC <- BrocANN(B.ANN.long)
reg_long_ROC <- Broc(B.reg.long.nocv, Btest)
rf_long_ROC <- Broc(B.rf.long.nocv, Btest)
long_ROC <- rbind(ANN_long_ROC, reg_long_ROC, rf_long_ROC)

ggplot(data = long_ROC, aes(fpr, tpr, color = model)) + geom_line()

ANN_short_ROC <- BrocANN(B.ANN.short)
reg_short_ROC <- Broc(B.reg.short.nocv, Btest)
rf_short_ROC <- Broc(B.rf.short.nocv, Btest)
short_ROC <- rbind(ANN_short_ROC, reg_short_ROC, rf_short_ROC)

ggplot(data = short_ROC, aes(fpr, tpr, color = model)) + geom_line()

ANN_ramp_ROC <- BrocANN(B.ANN.ramp)
reg_ramp_ROC <- Broc(B.reg.ramp.nocv, Btest)
rf_ramp_ROC <- Broc(B.rf.ramp.nocv, Btest)
ramp_ROC <- rbind(ANN_ramp_ROC, reg_ramp_ROC, rf_ramp_ROC)

ggplot(data = ramp_ROC, aes(fpr, tpr, color = model)) + geom_line()


```




